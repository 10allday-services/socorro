# -*- coding: utf-8 -*-
# Generated by Django 1.11.15 on 2018-09-26 23:40
from __future__ import print_function
from __future__ import unicode_literals

from django.db import connection, migrations


def copy_signature(apps, schema_editor):
    Signature = apps.get_model('crashstats', 'Signature')

    cursor = connection.cursor()

    # First, we verify the table is there. If not, we don't need to do anything.
    cursor.execute("""
    SELECT relname from pg_catalog.pg_class
    WHERE relname = 'signatures'
    """)
    row = cursor.fetchone()
    if row is None:
        print('no signatures table--nothing to do', end='')
        return

    # Second, pull all the data from it
    # NOTE(willkg): The old table has "first_report", but the new table has
    # "first_date".
    columns = ['signature', 'first_build', 'first_report']
    cursor.execute(
        """
        SELECT %(columns)s
        FROM signatures
        """ % {
            'columns': ', '.join(columns)
        }
    )

    insert_count = 0
    # Third, create new Signature instances and save them to the db.
    for row in cursor.fetchall():
        item = dict(zip(columns, row))
        Signature.objects.create(
            signature=item['signature'],
            first_build=item['first_build'],
            first_date=item['first_report']
        )
        insert_count += 1

    print('(inserted: %s)' % insert_count, end='')


def noop(apps, schema_editor):
    # No op because we have no idea which items came from the data migration
    # and which were created afterwards. The alternative is delete-the-all
    # and it's not hard to think of how epically disasterous that could be.
    pass


class Migration(migrations.Migration):

    dependencies = [
        ('crashstats', '0004_1463121-signature'),
    ]

    operations = [
        migrations.RunPython(copy_signature, noop),
    ]
